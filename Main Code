//////////////////////////////////////
=====================================
23/07/2020; 02:17
=====================================
//////////////////////////////////////
//Convolutional.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct sData{
	//Outside of identifiers.
	int memory_holder;
	int mirror[9];
	//Inside of identifiers.
	int sizes[2]; //[0]=lines, [1]=columns
	int imageSize[2];
	int **matrix;
	int *image;
	int *array;
} Dt;
//Dictionary:
//m==memory
//Dt=data, that is, the information for an entire convolution.
//mt=matrix.
//ar=array.
//mr=mirror
//[0]'s are mostly used for identifier. That means using them for the sake of positioning, then all arrays and matrices will have their [0] or [0][0] for identifying the position each one is for the sake of sync.
////////////////////
//Simple functions//
////////////////////
//====================================================
//Memory allocation function.
Dt* mAllocation (int mSize){
	Dt *data;
	data=(Dt*) malloc (mSize*sizeof(Dt)+sizeof(Dt)); //[0].imageSize is always a possible identifier,
	return data;
}
//====================================================
//Array allocation function.
int* mArAllocation (int mSize){
	int *data;
	data=(int*) malloc (mSize*sizeof(int)+sizeof(int)); //[0].imageSize is always a possible identifier,
	return data;
}
//====================================================
//Memory reallocation function.
Dt* mReallocation (Dt data[]){
	data=(Dt*) realloc(data, data[0].imageSize[0]*sizeof(Dt)+sizeof(Dt)+data[0].memory_holder);
	return data;
}
//====================================================
//Matrix memory allocation function.
void mtMAllocation (Dt data[]){
	printf("\nO valor real eh: %i\n", data[data[0].imageSize[0]].sizes[0]);
	int c;
	data[data[0].imageSize[0]].matrix=(int**) malloc(2*(data[data[0].imageSize[0]].sizes[0]*sizeof(int))); //[0].imageSize is always a possible identifier,
	for (c=0;c<=data[data[0].imageSize[0]].sizes[0];c++){ 
		data[data[0].imageSize[0]].matrix[c]=(int*) malloc(2*(data[data[0].imageSize[0]].sizes[0]*sizeof(int)));
	}
	data[0].memory_holder+=(2*(data[data[0].imageSize[0]].sizes[0]*sizeof(int)))*(2*(data[data[0].imageSize[0]].sizes[0]*sizeof(int)));
}
//====================================================
//Metrix creation.
void creatingMt(Dt data[]){
	data[data[0].imageSize[0]].sizes[0]=0;
	data[data[0].imageSize[0]].sizes[1]=0;
	printf("====================================================\n");
	printf("CURRENT POSITION: %i\n", data[0].imageSize[0]);
	printf("please, do insert number of lines (minimun 3): ");
	scanf("%i", &data[data[0].imageSize[0]].sizes[0]);
	data[data[0].imageSize[0]].sizes[0]=data[data[0].imageSize[0]].sizes[0]+4;
//	if (data[data[0].imageSize[0]].sizes[0]<7){
//		data[data[0].imageSize[0]].sizes[0]=7;
//	}
	printf("Please, do insert the number of columns (minimun 3): ");
	scanf("%i", &data[data[0].imageSize[0]].sizes[1]);
	data[data[0].imageSize[0]].sizes[1]=data[data[0].imageSize[0]].sizes[1]+4;
//	if (data[data[0].imageSize[0]].sizes[1]<7){
//		data[data[0].imageSize[0]].sizes[1]=7;
//	}
	mtMAllocation(data);
}
//====================================================
//////////////////
//Main functions//
//////////////////
//====================================================
//Matrix creation.
void mtCreation(Dt data[]){
	int sizes[2],c,j;
	//Creating and allocating the matrix.
	creatingMt(data);
	//Denulifying matrix.
	for (c=0;c<data[data[0].imageSize[0]].sizes[0];c++){
		for (j=0;j<data[data[0].imageSize[0]].sizes[1];j++){
			data[data[0].imageSize[0]].matrix[c][j]=0;
		}
	}
	//Loading matrix.
	for (c=2;c<data[data[0].imageSize[0]].sizes[0]-1;c++){
		for (j=2;j<data[data[0].imageSize[0]].sizes[1]-1;j++){
			printf("Insert the value for [%i][%i] ", c, j);
			scanf("%i", &data[data[0].imageSize[0]].matrix[c][j]);
		}
	}
	data[0].imageSize[0]++;
	printf("\nThe actual size is: %i\n", data[0].imageSize[0]);
	data=mReallocation(data);
}
//====================================================
//Main function.
int main (void){
	int loop=1;
	Dt *data;
	//data=mAllocation(mSize);
	data=mAllocation(1);
	data[0].imageSize[0]=1;
	data[0].memory_holder=8;
	//Main program.
	while(loop!=0){
		printf("====================================================\n");
		printf("Please, do insert your course of action: ");
		printf("\n\t1: creating a matrix.\n\t2: randomizing a matrix.\n\t3: Seing a matrix. \n\t4: Creating a mirror.\n\t5: Seing all mirrors.\n\t6: Convoluting a matrix with a mirror.\n\t7: Seing all convoluted arrays.\n\t8: Seing all convoluted matrices.\n\tType in '0' for exiting.\n");
		printf("Command: ");
		scanf("%i", &loop);
		switch (loop){
			case 0: break;
			case 1: mtCreation(&*data);
//			case 2: mtRandom(&*data);
//			case 3: seeMt(&*data);
//			case 4: createMr(&*data);
//			case 5: seeMr(&*data);
//			case 6: convoluteMt(&*data);
//			case 7: convolutedAr(&*data);
//			case 8: convolutedMt(&*data);
			default: loop=9;
		}
	}
	return 0;
}
//////////////////////////////////////
=====================================
24/07/2020||03:52
=====================================
//////////////////////////////////////
//Dictionary:
//m==memory
//Dt=data, that is, the information for an entire convolution.
//mt=matrix.
//ar=array.
//mr=mirror
//sz=size or sizes.
//im=image;
//id=identifier
//[0]'s are mostly used for identifier. That means using them for the sake of positioning, then all arrays and matrices will have their [0] or [0][0] for identifying the position each one is for the sake of sync.
//Convolutional.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define PP 12 //Size of a pointer.
#define ML 100 //Memory limit
typedef struct sData{
	int id[2];
	int sz[2];
	int *im;
	int *arIm;
	int **mt;
}Data;
////////////////////
//Simple functions//
////////////////////
//====================================================
//Initial memory allocation.
Data* MAllocation (int mSize){
	Data *data;
	data=(Data*) malloc (mSize*(sizeof(Data)+16)); //[0] is always a possible identifier,
	return data;
}
//====================================================
//Matrix memory allocation function.
void mtMAllocation (Data dt[]){
	int c;
	dt[dt[0].id[0]].mt=(int**) malloc(dt[dt[0].id[0]].sz[0]*PP); //[0].imageSize is always a possible identifier,
	if (dt[dt[0].id[0]].mt==NULL){
		printf("Memory failure.");
		exit(0);
	}
	for (c=0;c<=dt[dt[0].id[0]].sz[0];c++){ 
		dt[dt[0].id[0]].mt[c]=(int*) malloc(dt[dt[0].id[0]].sz[1]*sizeof(int));
		if (dt[dt[0].id[0]].mt[c]==NULL){
			printf("Memory failure.");
			exit(0);
		}
	}
}
//====================================================
//Matrix printer.
void mtPrinter(Data dt[], int position){
	int c,j;
	printf("\n-------------------------\n");
	printf("Matrix in position %i", position);
	printf("\n-------------------------\n");
	for (c=0;c<=dt[position].sz[0];c++){
		for (j=0;j<=dt[position].sz[1];j++){
			if (dt[position].mt[c][j]>=-9 && dt[position].mt[c][j]<=9){
				if(dt[position].mt[c][j]<=9 && dt[position].mt[c][j]>0){
					printf("###%i ", dt[position].mt[c][j]);
				}
				if (dt[position].mt[c][j]>=-9 && dt[position].mt[c][j]<0){
					printf("-##%i ", dt[position].mt[c][j]-=2*dt[position].mt[c][j]);
				}
				if (dt[position].mt[c][j]==0){
					printf("0000 ");
				}
			}
			if (dt[position].mt[c][j]<-9 || dt[position].mt[c][j]>9){
				if (dt[position].mt[c][j]>=-99 || dt[position].mt[c][j]<=99){
					if(dt[position].mt[c][j]<=99 && dt[position].mt[c][j]>0){
						printf("##%i ", dt[position].mt[c][j]);
					}
					if (dt[position].mt[c][j]>=-99 && dt[position].mt[c][j]<0){
						printf("#-%i ", dt[position].mt[c][j]-=2*dt[position].mt[c][j]);
					}
				}
			}
			if (dt[position].mt[c][j]<-99 || dt[position].mt[c][j]>99){
				if (dt[position].mt[c][j]>=-999 && dt[position].mt[c][j]<=999){
					if(dt[position].mt[c][j]<=999 && dt[position].mt[c][j]>0){
						printf("#%i ", dt[position].mt[c][j]);
					}
					if (dt[position].mt[c][j]>=-999 && dt[position].mt[c][j]<0){
						printf("-%i ", dt[position].mt[c][j]-=2*dt[position].mt[c][j]);
					}
				}
			}
		}
		printf("\n");
	}
	printf("\n-------------------------\n");
}
//====================================================
//////////////////
//Main functions//
//////////////////
//====================================================
//Matrix creation.
void creatingMt(Data dt[]){
	dt[dt[0].id[0]].sz[0]=0;
	dt[dt[0].id[0]].sz[1]=0;
	printf("====================================================\n");
	printf("CURRENT POSITION: %i\n", dt[0].id[0]);
	printf("please, do insert number of lines (minimun 3): ");
	scanf("%i", &dt[dt[0].id[0]].sz[0]);
	if (dt[dt[0].id[0]].sz[0]<3){
		dt[dt[0].id[0]].sz[0]=3;
	}
	dt[dt[0].id[0]].sz[0]+=4;
	printf("Please, do insert the number of columns (minimun 3): ");
	scanf("%i", &dt[dt[0].id[0]].sz[1]);
	if (dt[dt[0].id[0]].sz[1]<3){
		dt[dt[0].id[0]].sz[1]=3;
	}
	dt[dt[0].id[0]].sz[1]+=4;
	mtMAllocation(dt);
}
//====================================================
//Matrix loading.
void mtCreation(Data dt[]){
	int c,j;
	//Creating and allocating the matrix.
	creatingMt(dt);
	//Denulifying matrix.
	for (c=0;c<dt[dt[0].id[0]].sz[0];c++){
		for (j=0;j<dt[dt[0].id[0]].sz[1];j++){
			dt[dt[0].id[0]].mt[c][j]=0;
		}
	}
	//Loading matrix.
	for (c=2;c<dt[dt[0].id[0]].sz[0]-2;c++){
		for (j=2;j<dt[dt[0].id[0]].sz[1]-2;j++){
			printf("Insert the value for [%i][%i] ", c-1, j-1);
			scanf("%i", &dt[dt[0].id[0]].mt[c][j]);
		}
	}
	printf("\nNumber: %i\n", dt[dt[0].id[0]].mt[3][3]);
	dt[0].id[0]++;
}
//====================================================
//Random generator.
int ranGen(int lowest, int highest){
	int num;
	num=lowest+(rand()%(highest-lowest+1));
	return num;
}
//====================================================
//Random matrix.
void mtRandom(Data dt[]){
	int c,j,num,l=0,h=101;
	//Creating and allocating the matrix.
	creatingMt(dt);
	//Denulifying matrix.
	for (c=0;c<dt[dt[0].id[0]].sz[0];c++){
		for (j=0;j<dt[dt[0].id[0]].sz[1];j++){
			dt[dt[0].id[0]].mt[c][j]=0;
		}
	}
	//Loading.
	while (l>99 && l<-99){
		printf("Insert the lowest number in range within -99 and 99: ");
		scanf("%i", &l);
		if (l>99 && l<-99){
			printf("Please, insert a valid number.");
		}
	}
	while (h>99 && h<-99){
		printf("Insert the highest number in range within -99 and 99: ");
		scanf("%i", &h);
		if (h>99 && h<-99){
			printf("Please, insert a valid number.");
		}
	}
	for (c=2;c<dt[dt[0].id[0]].sz[0]-2;c++){
		for (j=2;j<dt[dt[0].id[0]].sz[1]-2;j++){
			dt[dt[0].id[0]].mt[c][j]=ranGen(l,h);
		}
	}
	dt[0].id[0]++;
}
//====================================================
//Seing a matrix.
void seing (Data dt[]){
	int position,c,j;
	printf("====================================================\n");
	printf("Insert position '-1' for exiting.\n");
	while (position!=-1){
		printf("Please, insert the position of the desired matrix: ");
		scanf("%i", &position);
		if (position==-1){
			break;
		}
		mtPrinter(dt, position);
	}
}
void mMenu(int loop, Data dt[]){
	switch (loop){
		case 0: break;
		case 1: mtCreation(dt);break;
		case 2: mtRandom(dt);break;
		case 3: seing(dt);break;
//		case 4: createMr(&*dt);
//		case 5: seeMr(&*dt);
//		case 6: convoluteMt(&*dt);
//		case 7: convolutedAr(&*dt);
//		case 8: convolutedMt(&*dt);
		default:break;
	}
}
//====================================================
//Main function.
int main (void){
	int loop=9;
	Data *dt;
	dt=MAllocation(100);
	dt[0].id[0]=1;
	srand(time(NULL));
	//Main program.
	while(loop!=0){
		printf("====================================================\n");
		printf("Please, do insert your course of action: ");
		printf("\n\t1: creating a matrix.\n\t2: randomizing a matrix.\n\t3: Seing a matrix. \n\t4: Creating a mirror.\n\t5: Seing all mirrors.\n\t6: Convoluting a matrix with a mirror.\n\t7: Seing all convoluted arrays.\n\t8: Seing all convoluted matrices.\n\tType in '0' for exiting.\n");
		printf("Command: ");
		scanf("%i", &loop);
		mMenu(loop, dt);

	}
	return 0;
}
